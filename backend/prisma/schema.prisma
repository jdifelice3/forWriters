generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum CommentSource {
  DOCX
  MANUAL
}

enum DocumentType {
  MANUSCRIPT
  FEEDBACK
}

enum ParticipantType {
  AUTHOR
  REVIEWER
}

enum EventType {
  READING
  RETREAT
}

enum Genre {
  FANTASY
  HISTORICAL
  HORROR
  LITERARY
  MYSTERY
  POEM
  ROMANCE
  SCIENCEFICTION
}

enum FileType {
  DOCX
  PDF
}

enum GroupType {
  WRITING
}

enum JoinRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

enum GroupMemberRole {
  MEMBER
  ADMIN
}

enum ReadingScheduleType {
    SCHEDULED
    UNSCHEDULED
}

enum Role {
  ADMIN
  AUTHOR
  EDITOR
  READER
}

enum UrlOwnerType {
  USER
  WRITINGGROUP
}

enum UrlType {
  AUDIO
  FACEBOOK
  IMAGE
  LINKEDIN
  MEETUP
  SUBSTACK
  WEBSITE
  YOUTUBE
}

enum WorkType {
  FLASHFICTION
  NOVEL
  NOVELLA
  NOVELETTE
  PLAY
  SCREENPLAY
  SERIALIZEDFICTION
  SHORTSTORY
}

model AppFile {
  id                  String       @id @default(cuid())
  userId              String
  title               String
  description         String?
  filename            String
  documentType        DocumentType @default(MANUSCRIPT)
  mimetype            FileType     @default(PDF)
  url                 String
  uploadedAt          DateTime     @default(now())
  workType            WorkType?
  wordCount           Int?
  pageCount           Int?
  genre               Genre?
  manuscriptIsVisible Boolean      @default(false)

  user            User              @relation("AppFileOwner", fields: [userId], references: [id])
  readingFeedback ReadingFeedback[]
  authorAppFile   AuthorAppFile[]
}

model AuthorAppFile {
  id              String   @id @default(cuid())
  readingAuthorId String   @unique
  appFileId       String
  createdAt       DateTime @default(now())

  readingAuthor ReadingAuthor @relation(fields: [readingAuthorId], references: [id])
  appFile       AppFile       @relation(fields: [appFileId], references: [id])
}

model CollaboratorRequest {
  id                        String                  @id @default(cuid())
  userId                    String
  collaboratorId            String
  status                    JoinRequestStatus       @default(PENDING)
  createdAt DateTime                                @default(now())
  updatedAt DateTime                                @updatedAt

  //user                      User                    @relation(fields: [userId], references: [id])
  user                User                @relation(name: "UserRequest", fields: [userId], references: [id])
  collaboratorUser    User                @relation(name: "UserCollaboratorRequest", fields: [collaboratorId], references: [id])

  @@index([userId])
  @@index([status])
}

model Group {
  id            String    @id @default(cuid())
  creatorUserId String
  groupType     GroupType @default(WRITING)
  name          String    @unique
  description   String?
  imageUrl      String?
  websiteUrl    String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  groupAddress GroupAddress[]
  groupUser    GroupUser[]
  groupNews    GroupNews[]
  reading      Reading[]
  groupUrl     GroupUrl[]
  user         User           @relation(fields: [creatorUserId], references: [id])
  joinRequests JoinRequest[]
}

model GroupAddress {
  id     String @id @default(cuid())
  street String
  city   String
  state  String
  zip    String

  groupId String
  group   Group?   @relation(fields: [groupId], references: [id])
  reading Reading?
}

model GroupNews {
  id       String   @id @default(cuid())
  groupId  String
  title    String
  content  String?
  postedAt DateTime @default(now())
  archived Boolean  @default(false)

  group Group @relation(fields: [groupId], references: [id])
}

model GroupUser {
  id        String   @id @default(cuid())
  userId    String
  groupId   String
  isAdmin   Boolean  @default(false)
  invitedBy String?
  createdAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id])
  group Group @relation(fields: [groupId], references: [id])

  @@unique([groupId, userId])
}

model GroupUrl {
  id        String   @id @default(cuid())
  url       String
  groupId   String
  urlType   UrlType  @default(WEBSITE)
  createdAt DateTime @default(now())

  group Group? @relation(fields: [groupId], references: [id])
}

model JoinRequest {
  id        String            @id @default(cuid())
  userId    String
  groupId   String
  status    JoinRequestStatus @default(PENDING)
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt

  user  User  @relation(fields: [userId], references: [id])
  group Group @relation(fields: [groupId], references: [id])

  @@index([userId])
  @@index([groupId])
  @@index([status])
}

model Reading {
  id                  String   @id @default(cuid())
  name                String
  groupId             String
  createdAt           DateTime @default(now())
  createdUserId       String
  readingDate         DateTime?
  readingStartTime    String?
  readingEndTime      String?
  readingAddressId    String?  @unique
  submissionDeadline  DateTime?
  spotsOpen           Int      @default(2)
  description         String
  minDaysBetweenReads Int      @default(20) // configurable
  maxConsecutiveReads Int      @default(1) // e.g., can't sign up twice in a row
  scheduledType          ReadingScheduleType    @default(SCHEDULED)

  user          User            @relation(fields: [createdUserId], references: [id])
  readingAuthor ReadingAuthor[]
  group         Group           @relation(fields: [groupId], references: [id])
  groupAddress  GroupAddress?   @relation(fields: [readingAddressId], references: [id])
}

model ReadingAuthor {
  id        String   @id @default(cuid())
  readingId String
  authorId  String
  joinedAt  DateTime @default(now())

  reading         Reading           @relation(fields: [readingId], references: [id])
  user            User              @relation("ReadingAuthorUser", fields: [authorId], references: [id])
  authorAppFile   AuthorAppFile?
  readingFeedback ReadingFeedback[]

  @@unique([readingId, authorId])
}

model ReadingFeedback {
  id              String   @id @default(cuid())
  readingAuthorId String
  feedbackUserId  String
  feedbackFileId  String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  readingAuthor          ReadingAuthor            @relation(fields: [readingAuthorId], references: [id])
  readingFeedbackComment ReadingFeedbackComment[]
  appFile                AppFile                  @relation(fields: [feedbackFileId], references: [id])
  user                   User                     @relation("FeedbackUser", fields: [feedbackUserId], references: [id])
}

model ReadingFeedbackComment {
  id                String        @id @default(cuid())
  readingAuthorId   String
  readingFeedbackId String
  source            CommentSource @default(DOCX)
  commentText       String
  targetText        String

  readingFeedback ReadingFeedback @relation(fields: [readingFeedbackId], references: [id])
}

model User {
  id            String   @id @default(cuid())
  superTokensId String   @unique
  email         String   @unique
  role          Role     @default(READER)
  username      String   @unique
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  userProfile UserProfile?

  groupUser           GroupUser[]
  group               Group[]
  reading             Reading[]
  appFiles            AppFile[]             @relation("AppFileOwner")
  urls                UserUrl[]
  joinRequests        JoinRequest[]
  readingFeedback     ReadingFeedback[]     @relation("FeedbackUser")
  readingAuthor       ReadingAuthor[]       @relation("ReadingAuthorUser")
  userInviter         UserCollaborator[]    @relation("User")
  userCollaborator    UserCollaborator[]    @relation("UserCollaborator")
  userRequestor       CollaboratorRequest[]                         @relation("UserRequest")
  collaboratorUserRequestor    CollaboratorRequest[]                @relation("UserCollaboratorRequest")

}

model UserCollaborator {
    id                  String              @id @default(cuid())
    userId              String
    collaboratorId      String
    createdAt DateTime                      @default(now())
    updatedAt DateTime                      @updatedAt

    user                User                @relation(name: "User", fields: [userId], references: [id])
    collaboratorUser    User                @relation(name: "UserCollaborator", fields: [collaboratorId], references: [id])
}

model UserProfile {
  id   String @id // Primary key
  user User   @relation(fields: [id], references: [id]) // FK lives here

  firstName String?
  lastName  String?
  phone     String?
  bio       String?
}

model UserSearch {
  id       String @id
  fullName String?
  bio      String?

  @@map("UserSearch")
}


model UserUrl {
  id        String   @id @default(cuid())
  url       String
  userId    String
  urlType   UrlType  @default(WEBSITE)
  createdAt DateTime @default(now())

  user User? @relation(fields: [userId], references: [id])
}

//create view "UserSearch" as SELECT id, "firstName" || ' ' || "lastName" AS "fullName", bio from "UserProfile";