generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum CommentSource {
  DOCX
  MANUAL
}

enum DocumentType {
  MANUSCRIPT
  VERSION
  FEEDBACK
}

enum FileType {
  DOCX
  PDF
}

enum EventType {
  READING
  RETREAT
}

enum Genre {
  FANTASY
  HISTORICAL
  HORROR
  LITERARY
  MYSTERY
  POEM
  ROMANCE
  SCIENCEFICTION
}

enum GroupType {
  WRITING
  PERSONAL
}

enum GroupRole {
  OWNER
  MEMBER
  ADMIN
  READER
}

enum JoinRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

enum NotificationType {
  GROUP_JOIN_REQUEST
  GROUP_INVITE
  COLLAB_REQUEST
  READING_FEEDBACK
}

enum ParticipantType {
  AUTHOR
  REVIEWER
}

enum ReadingScheduleType {
    SCHEDULED
    UNSCHEDULED
}

enum Role {
  ADMIN
  AUTHOR
  EDITOR
  READER
}

enum UrlOwnerType {
  USER
  WRITINGGROUP
}

enum UrlType {
  AUDIO
  FACEBOOK
  IMAGE
  LINKEDIN
  MEETUP
  SUBSTACK
  WEBSITE
  YOUTUBE
}

enum WorkType {
  FLASHFICTION
  NOVEL
  NOVELLA
  NOVELETTE
  PLAY
  SCREENPLAY
  SERIALIZEDFICTION
  SHORTSTORY
}

model AppFile {
  id                  String       @id @default(cuid())
  appFileMetaId       String
  name                String       @default("none")
  version             Int          @default(1)
  userId              String
  filename            String
  documentType        DocumentType @default(MANUSCRIPT)
  mimetype            FileType     @default(DOCX)
  url                 String
  uploadedAt          DateTime     @default(now())
  workType            WorkType?
  wordCount           Int?
  pageCount           Int?
  genre               Genre?
  manuscriptIsVisible Boolean      @default(false)
  versionComment      String?
  createdAt           DateTime      @default(now())

  appFileMeta    AppFileMeta        @relation("OriginalAppFile", fields: [appFileMetaId], references: [id])
  readingSubmission  ReadingSubmission[]
  fileFeedback       FileFeedback[]

  @@unique([appFileMetaId, version])
}

model AppFileMeta {
    id                  String          @id @default(cuid())
    userId              String
    title               String
    description         String
    documentType        DocumentType    @default(MANUSCRIPT)
    currentVersionId    Int
    createdAt           DateTime        @default(now())
    updatedAt           DateTime        @default(now())
    deletedAt           DateTime?

    user                User         @relation("AppFileOwnerUser", fields: [userId], references: [id])
    appFile             AppFile[]    @relation("OriginalAppFile") 
}

model CollaboratorRequest {
  id                        String                  @id @default(cuid())
  userId                    String
  collaboratorId            String
  status                    JoinRequestStatus       @default(PENDING)
  createdAt DateTime                                @default(now())
  updatedAt DateTime                                @updatedAt

  //user                      User                    @relation(fields: [userId], references: [id])
  user                User                @relation(name: "UserRequest", fields: [userId], references: [id])
  collaboratorUser    User                @relation(name: "UserCollaboratorRequest", fields: [collaboratorId], references: [id])

  @@index([userId])
  @@index([status])
}

model Group {
  id            String    @id @default(cuid())
  creatorUserId String
  groupType     GroupType @default(WRITING)
  name          String    @unique
  description   String?
  imageUrl      String?
  websiteUrl    String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  groupAddress GroupAddress[]
  groupUser    GroupUser[]
  groupNews    GroupNews[]
  reading      Reading[]
  groupUrl     GroupUrl[]
  user         User           @relation(fields: [creatorUserId], references: [id])
  joinRequests JoinRequest[]
  groupInvite  GroupInvite[]
}

model GroupAddress {
  id     String @id @default(cuid())
  street String
  city   String
  state  String
  zip    String

  groupId String
  group   Group?   @relation(fields: [groupId], references: [id])
  reading Reading? 
}

model GroupInvite {
  id          String   @id @default(uuid())
  groupId     String
  email       String
  role        GroupRole
  tokenHash   String
  expiresAt   DateTime
  acceptedAt DateTime?
  createdAt  DateTime @default(now())

  group Group @relation(fields: [groupId], references: [id])

  @@unique([groupId, email])
}

model GroupNews {
  id       String   @id @default(cuid())
  groupId  String
  content  String?
  postedAt DateTime @default(now())
  archived Boolean  @default(false)

  group Group @relation(fields: [groupId], references: [id])
}

model GroupUser {
  id        String   @id @default(cuid())
  userId    String
  groupId   String
  role   GroupRole  @default(MEMBER)
  invitedBy String?
  createdAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id])
  group Group @relation(fields: [groupId], references: [id])

  @@unique([groupId, userId])
}

model GroupUrl {
  id        String   @id @default(cuid())
  url       String
  groupId   String
  urlType   UrlType  @default(WEBSITE)
  createdAt DateTime @default(now())

  group Group? @relation(fields: [groupId], references: [id])
}

model JoinRequest {
  id        String            @id @default(cuid())
  userId    String
  groupId   String
  status    JoinRequestStatus @default(PENDING)
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt

  user  User  @relation(fields: [userId], references: [id])
  group Group @relation(fields: [groupId], references: [id])

  @@index([userId])
  @@index([groupId])
  @@index([status])
}

model Notification {
  id        String   @id @default(uuid())
  userId    String
  type      NotificationType
  entityId  String
  message   String
  createdAt DateTime @default(now())
  readAt    DateTime?
}

model Reading {
  id                  String   @id @default(cuid())
  name                String
  groupId             String
  createdAt           DateTime @default(now())
  createdUserId       String
  readingDate         DateTime?
  readingStartTime    String?
  readingEndTime      String?
  readingAddressId    String?  @unique
  submissionDeadline  DateTime?
  spotsOpen           Int      @default(2)
  description         String
  minDaysBetweenReads Int      @default(20) // configurable
  maxConsecutiveReads Int      @default(1) // e.g., can't sign up twice in a row
  scheduledType          ReadingScheduleType    @default(SCHEDULED)

  user          User            @relation(fields: [createdUserId], references: [id])
  readingParticipant ReadingParticipant[]
  group         Group           @relation(fields: [groupId], references: [id])
  groupAddress  GroupAddress?   @relation(fields: [readingAddressId], references: [id])
  readingSubmission         ReadingSubmission[]
}

model FileFeedback {
  id                    String   @id @default(cuid())

  reviewerParticipantId String
  appFileId             String

  // optional contextual link
  submissionId          String?  

  createdAt             DateTime @default(now())

  reviewerParticipant   ReadingParticipant @relation(fields: [reviewerParticipantId], references: [id])
  appFile               AppFile            @relation(fields: [appFileId], references: [id])
  submission            ReadingSubmission? @relation(fields: [submissionId], references: [id])

  fileFeedbackComment   FileFeedbackComment[]

  @@unique([appFileId, reviewerParticipantId]) // ðŸ”’ canonical identity
  @@index([submissionId])
}



model FileFeedbackComment {
  id                   String   @id @default(cuid())
  fileFeedbackId       String   // rename from readingFeedbackId
  reviewerParticipantId String
  source               CommentSource @default(DOCX)
  commentText          String
  isResolved           Boolean  @default(false)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  fileFeedback         FileFeedback @relation(fields: [fileFeedbackId], references: [id])
  readingParticipant   ReadingParticipant @relation(fields: [reviewerParticipantId], references: [id])
  targets              FileFeedbackCommentTarget[]

  @@index([fileFeedbackId])
  @@index([reviewerParticipantId])
}


model FileFeedbackCommentTarget {
  id                 String   @id @default(cuid())
  commentId           String
  paragraphId         String
  from                Int
  to                  Int
  targetText          String

  createdAt           DateTime @default(now())

  comment             FileFeedbackComment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@index([commentId])
  @@index([paragraphId])
  @@index([from])
}

model ReadingParticipant {
  id        String   @id @default(cuid())
  readingId String
  userId    String
  joinedAt  DateTime @default(now())

  reading   Reading @relation(fields: [readingId], references: [id])
  user      User    @relation("ReadingParticipantUser", fields: [userId], references: [id])

  readingSubmission ReadingSubmission?
  fileFeedback   FileFeedback[]
  fileFeedbackComment FileFeedbackComment[]

  @@unique([readingId, userId])
}

model ReadingSubmission {
  id             String   @id @default(cuid())
  readingId      String
  participantId  String    @unique
  appFileId      String
  submittedAt    DateTime @default(now())

  reading       Reading   @relation(fields: [readingId], references: [id])
  participant   ReadingParticipant    @relation(fields: [participantId], references: [id])
  appFile       AppFile  @relation(fields: [appFileId], references: [id])
  fileFeedback       FileFeedback[]
  @@unique([readingId, participantId, appFileId])
}

model User {
  id            String   @id @default(cuid())
  superTokensId String   @unique
  email         String   @unique
  role          Role     @default(READER)
  username      String   @unique
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  userProfile UserProfile?

  groupUser           GroupUser[]
  group               Group[]
  reading             Reading[]
  appFileMetas            AppFileMeta[]                             @relation("AppFileOwnerUser")
  urls                UserUrl[]
  joinRequests        JoinRequest[]
  readingParticipant       ReadingParticipant[]                       @relation("ReadingParticipantUser")
  userInviter         UserCollaborator[]                    @relation("User")
  userCollaborator    UserCollaborator[]                    @relation("UserCollaborator")
  userRequestor       CollaboratorRequest[]                 @relation("UserRequest")
  collaboratorUserRequestor    CollaboratorRequest[]        @relation("UserCollaboratorRequest")
}

model UserCollaborator {
    id                  String              @id @default(cuid())
    userId              String
    collaboratorId      String
    createdAt DateTime                      @default(now())
    updatedAt DateTime                      @updatedAt

    user                User                @relation(name: "User", fields: [userId], references: [id])
    collaboratorUser    User                @relation(name: "UserCollaborator", fields: [collaboratorId], references: [id])
}

model UserProfile {
  id   String @id // Primary key
  user User   @relation(fields: [id], references: [id]) // FK lives here

  firstName String?
  lastName  String?
  phone     String?
  bio       String?
  avatarUrl String?
}

model UserSearch {
  userId       String     @id
  fullName String?
  bio      String?
}

model UserUrl {
  id        String   @id @default(cuid())
  url       String
  userId    String
  urlType   UrlType  @default(WEBSITE)
  createdAt DateTime @default(now())

  user User? @relation(fields: [userId], references: [id])
}

//create view "UserSearch" as SELECT id, "firstName" || ' ' || "lastName" AS "fullName", bio from "UserProfile";